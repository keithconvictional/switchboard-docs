"use strict";(self.webpackChunkswitchboard=self.webpackChunkswitchboard||[]).push([[329],{3905:function(e,t,o){o.d(t,{Zo:function(){return s},kt:function(){return h}});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function a(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var u=n.createContext({}),c=function(e){var t=n.useContext(u),o=t;return e&&(o="function"==typeof e?e(t):a(a({},t),e)),o},s=function(e){var t=c(e.components);return n.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=c(o),h=r,m=p["".concat(u,".").concat(h)]||p[h]||d[h]||i;return o?n.createElement(m,a(a({ref:t},s),{},{components:o})):n.createElement(m,a({ref:t},s))}));function h(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=o.length,a=new Array(i);a[0]=p;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var c=2;c<i;c++)a[c]=o[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,o)}p.displayName="MDXCreateElement"},5384:function(e,t,o){o.r(t),o.d(t,{frontMatter:function(){return l},contentTitle:function(){return u},metadata:function(){return c},toc:function(){return s},default:function(){return p}});var n=o(7462),r=o(3366),i=(o(7294),o(3905)),a=["components"],l={},u="How to Build Word Count Switch for Convictional Products",c={unversionedId:"tutorials/how-to-build-word-count-switch-for-convictional-products",id:"tutorials/how-to-build-word-count-switch-for-convictional-products",isDocsHomePage:!1,title:"How to Build Word Count Switch for Convictional Products",description:'In this guide, we walk through building a Switch that counts the number of words in a product description. The products are pulled from the Convictional API, number of words is calculated, then the results are push under product.Attributes["word_count"] back onto the API.',source:"@site/docs/tutorials/how-to-build-word-count-switch-for-convictional-products.md",sourceDirName:"tutorials",slug:"/tutorials/how-to-build-word-count-switch-for-convictional-products",permalink:"/switchboard-docs/docs/tutorials/how-to-build-word-count-switch-for-convictional-products",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/tutorials/how-to-build-word-count-switch-for-convictional-products.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Rate Limiting on Outbound Requests",permalink:"/switchboard-docs/docs/deployments/rate-limiting"},next:{title:"building-a-switch-for-scheduling-pricelists",permalink:"/switchboard-docs/docs/tutorials/building-a-switch-for-scheduling-pricelists"}},s=[{value:"Code",id:"code",children:[],level:2},{value:"Deploy",id:"deploy",children:[],level:2},{value:"Testing",id:"testing",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],d={toc:s};function p(e){var t=e.components,o=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-build-word-count-switch-for-convictional-products"},"How to Build Word Count Switch for Convictional Products"),(0,i.kt)("p",null,"In this guide, we walk through building a Switch that counts the number of words in a product description. The products are pulled from the Convictional API, number of words is calculated, then the results are push under ",(0,i.kt)("inlineCode",{parentName:"p"},'product.Attributes["word_count"]')," back onto the API."),(0,i.kt)("p",null,"This code will run on an AWS Lambda. It will be scheduled for once an hour. We could make it webhook based but we will keep it simple for now. If you have a large number of products, you will need to switch to using webhooks or multiple functions. The general flow of data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Convictional Products API --\x3e AWS Lambda running Switch Code --\x3e Convictional Products API\n")),(0,i.kt)("p",null,"We are assuming you have an AWS account, the AWS CLI installed, and Switchboard CLI installed."),(0,i.kt)("h2",{id:"code"},"Code"),(0,i.kt)("p",null,"Let's get started with writing the code. Create a new repository and clone it to your local machine."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"git clone git@github.com:your-username/your-repo-name.git\ncd your-repo-name\n")),(0,i.kt)("p",null,"Run the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"switchboard new switch\n")),(0,i.kt)("p",null,"This should take a few seconds, but you should be able to now see files. Open the project in your favourite editor."),(0,i.kt)("p",null,"First, the Extract step of ETL will pull from the Convictional products API. If you look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"extract/convictional.go"),", it has ",(0,i.kt)("inlineCode",{parentName:"p"},"GetProductsFromAPI"),". It comes out of the box. It requires two environment variables: ",(0,i.kt)("inlineCode",{parentName:"p"},"CONVICTIONAL_API_KEY")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IS_BUYER"),". We need to indicate that we want to pull from Convictional compared another source (Ex. SQS). Look at ",(0,i.kt)("inlineCode",{parentName:"p"},"extract/extract.go"),", and in ",(0,i.kt)("inlineCode",{parentName:"p"},"Multiple"),", we call ",(0,i.kt)("inlineCode",{parentName:"p"},"GetProductsFromAPI"),". The switch statement depends on ",(0,i.kt)("inlineCode",{parentName:"p"},"EXTRACT_METHOD")," environment variable."),(0,i.kt)("p",null,"The too long, didn't read (TLDR) is that we need to set:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"EXTRACT_METHOD")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"convictional_api")),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"CONVICTIONAL_API_KEY")," with your API key (",(0,i.kt)("a",{parentName:"li",href:"https://developers.convictional.com/reference/introduction#get-your-api-key"},"How to find it"),")"),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"IS_BUYER")," this is ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," depending on your Convictional account.")),(0,i.kt)("p",null,"That's it for pulling product information. Next is the transform step. This goes into ",(0,i.kt)("inlineCode",{parentName:"p"},"transform/transform.go"),". Here is the updated code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'package transform\n\nimport (\n    "regexp"\n    "strconv"\n    "strings"\n    "switchboard-module-boilerplate/models"\n)\n\nconst regex = `<.*?>`\nconst wordCountAttributeKey = "word_count"\n\n// Transform returns processed flagged, the updated model, and error.\n// Products that have already been processed will be returned as false.\nfunc Transform(product models.Product) (bool, models.Product, error) {\n    if _, ok := product.Attributes[wordCountAttributeKey]; ok {\n        // Already exists\n        return false, models.Product{}, nil\n    }\n\n    description := stripHtmlRegex(product.Description)\n\n    // Count words\n    if product.Attributes == nil {\n        product.Attributes = map[string]interface{}{}\n    }\n    product.Attributes[wordCountAttributeKey] = strconv.Itoa(CountWords(description))\n\n    return true, product, nil\n}\n\n// This method uses a regular expresion to remove HTML tags.\nfunc stripHtmlRegex(s string) string {\n    r := regexp.MustCompile(regex)\n    return r.ReplaceAllString(s, "")\n}\n\n\nfunc CountWords(s string)  int {\n    return len(strings.Fields(s))\n}\n')),(0,i.kt)("p",null,"This code took less than 10 minutes to write. This is why we are using the Switchboard framework."),(0,i.kt)("p",null,"The third step of our ETL work is the Load. We are loading back into the Convictional API. Look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"load/load.go")," and specifically ",(0,i.kt)("inlineCode",{parentName:"p"},"Multiple"),". It loops through each of the products, if its updated pushes a API call to Convictional. We need to set the environment variable for indicating how we want to load, so ",(0,i.kt)("inlineCode",{parentName:"p"},"LOAD_METHOD")," should be set with ",(0,i.kt)("inlineCode",{parentName:"p"},"convictional_api"),". In terms of rate limiting, that comes out of the box."),(0,i.kt)("p",null,"That's it! Your code should be ready to be deployed. I recommend committing this code to version control."),(0,i.kt)("h2",{id:"deploy"},"Deploy"),(0,i.kt)("p",null,"As previously mentioned, we are going to deploy to AWS Lambda. We are going to use the CLI to deploy this code. There are two ways the deploy command captures information; input or file. For input, it will prompt us with questions and you need to answer. Ex. What are the triggers? For file, you make reference to a config yaml file path in the deploy command."),(0,i.kt)("p",null,"We are going to go through the prompts. The config file is excellent if it is being deployed through a continuous delivery pipeline."),(0,i.kt)("p",null,"Just a reminder, the CLI command is structured as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"switchboard deploy <platform> <flow> <optional config path>\n")),(0,i.kt)("p",null,"We are going to run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"switchboard deploy aws Convictional--Func1--Convictional\n")),(0,i.kt)("p",null,"This will kick off the deployment of one serverless function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# What is the name of your Func1? (Alpha-numeric characters only)\n> word-count-switch\n\n# What will trigger Func1? (Bar delimited, Options: schedule, webhook)\n> schedule\n\n# What time should Func1 trigger? (Express as Cron: http://www.cronmaker.com/)\n> 0 0 0/1 1/1 * ? *\n\n# We have preset the follow environment variables based on your flow for Func1:\n# EXTRACT_METHOD=convictional_api\n# LOAD_METHOD=convictional_api\n\n# What should CONVICTIONAL_API_KEY be set as for Func1?\n> redacted_from_tutorial\n\n# What should IS_BUYER be set as for Func1?\n> false\n\nDeploying to us-east-2 (default region)...\nDone, check it out: https://us-east-2.console.aws.amazon.com/lambda/home?region=us-east-2#/functions/word-count-switch\n")),(0,i.kt)("p",null,"We are setup on the cloud. Every hour this Lambda function will pull down products from the products API, execute the transformation and update through the API."),(0,i.kt)("h2",{id:"testing"},"Testing"),(0,i.kt)("p",null,"TODO"),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"TODO"))}p.isMDXComponent=!0}}]);